import fs from "fs/promises";
import fsSync from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Header marker for managed files
export const MANAGED_HEADER_MARKER = "AUTO-GENERATED BY APP-KIT - DO NOT EDIT";

// Get the templates directory
export function getTemplatesDir(): string {
  // In development: src/cli -> templates
  // In production: dist/cli -> ../templates
  const devPath = path.resolve(__dirname, "../../templates");
  const prodPath = path.resolve(__dirname, "../../../templates");
  
  // Check which exists
  if (fsSync.existsSync(devPath)) return devPath;
  if (fsSync.existsSync(prodPath)) return prodPath;
  
  return prodPath;
}

// Get app-kit version
export async function getAppKitVersion(): Promise<string> {
  try {
    const pkgPath = path.resolve(__dirname, "../../package.json");
    const content = await fs.readFile(pkgPath, "utf-8");
    return JSON.parse(content).version;
  } catch {
    return "unknown";
  }
}

// Generate managed file header based on file type
export function generateHeader(fileType: string, version: string): string {
  const headerLines = [
    `===== ${MANAGED_HEADER_MARKER} =====`,
    `This file is managed by @mchen-lab/app-kit and will be`,
    `overwritten when running \`npx @mchen-lab/app-kit update\`.`,
    `Version: ${version}`,
    `=`.repeat(52),
  ];

  switch (fileType) {
    case "shell":
    case "yaml":
    case "dockerfile":
      return headerLines.map((line) => `# ${line}`).join("\n") + "\n\n";
    case "typescript":
    case "javascript":
      return (
        "/**\n" +
        headerLines.map((line) => ` * ${line}`).join("\n") +
        "\n */\n\n"
      );
    case "json":
      // JSON doesn't support comments, skip header
      return "";
    default:
      return headerLines.map((line) => `# ${line}`).join("\n") + "\n\n";
  }
}

// Detect file type from extension
export function getFileType(filename: string): string {
  const ext = path.extname(filename).toLowerCase();
  const basename = path.basename(filename).toLowerCase();

  if (basename === "dockerfile") return "dockerfile";
  if (ext === ".sh") return "shell";
  if (ext === ".yml" || ext === ".yaml") return "yaml";
  if (ext === ".ts") return "typescript";
  if (ext === ".js") return "javascript";
  if (ext === ".json") return "json";

  return "shell"; // default
}

// Check if a file has the managed header (comment or JSON property)
export async function isManagedFile(filePath: string): Promise<boolean> {
  try {
    const content = await fs.readFile(filePath, "utf-8");
    
    // Check for comment-based header
    if (content.includes(MANAGED_HEADER_MARKER)) {
      return true;
    }
    
    // Check for JSON-based marker (_appKitManaged property)
    if (filePath.endsWith(".json")) {
      try {
        const json = JSON.parse(content);
        if (json._appKitManaged === true) {
          return true;
        }
      } catch {
        // Not valid JSON
      }
    }
    
    return false;
  } catch {
    return false;
  }
}

// Replace template variables
export function processTemplate(
  content: string,
  variables: Record<string, string>
): string {
  let result = content;
  for (const [key, value] of Object.entries(variables)) {
    result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, "g"), value);
  }
  return result;
}

// List of managed files (relative to project root)
export const MANAGED_FILES = [
  "Dockerfile",
  "tsconfig.server.json",
  "vite.config.ts",
  ".github/workflows/ci.yml",
  "devops/release.sh",
  "devops/build_and_publish.sh",
  "devops/docker_relaunch.sh",
  "restart.sh",
];

// Ensure directory exists
export async function ensureDir(dirPath: string): Promise<void> {
  await fs.mkdir(dirPath, { recursive: true });
}

// Copy file with optional processing
export async function copyFile(
  src: string,
  dest: string,
  process?: (content: string) => string
): Promise<void> {
  let content = await fs.readFile(src, "utf-8");
  if (process) {
    content = process(content);
  }
  await ensureDir(path.dirname(dest));
  await fs.writeFile(dest, content);
}
